use std::{collections::BTreeSet, num::NonZeroU32};

use rand::{CryptoRng, RngCore};

pub type CharSet = BTreeSet<char>;

/// A password specification containing all information to generate a password.
#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub struct PasswordSpec {
    length: NonZeroU32,
    char_sets: Vec<CharSet>,
    char_set_union: Vec<char>,
}

impl PasswordSpec {
    /// Creates a new password specification, asserting all its invariants.
    pub fn new(length: NonZeroU32, char_sets: Vec<CharSet>) -> Self {
        assert!(
            !char_sets.is_empty(),
            "vector of character sets must not be empty"
        );

        let char_set_union = {
            let union_set = char_sets
                .iter()
                .cloned()
                .fold(CharSet::new(), |mut acc, mut x| {
                    assert!(!x.is_empty(), "character sets must not be empty");
                    acc.append(&mut x);
                    acc
                });
            Vec::from_iter(union_set.into_iter())
        };

        // this assert is technically impossible to be false,
        // because the set of char sets is non-empty
        // and each char set is non-empty
        assert!(
            !char_set_union.is_empty(),
            "union of character sets should not be empty"
        );

        Self {
            length,
            char_sets,
            char_set_union,
        }
    }

    /// Returns the non-zero length of the generated password.
    pub fn length(&self) -> NonZeroU32 {
        self.length
    }

    /// Returns the non-empty alice of non-empty character sets to sample from.
    pub fn char_sets(&self) -> &[CharSet] {
        self.char_sets.as_ref()
    }

    /// Returns the non-empty union of the [character sets](Self::char_sets).
    pub fn char_set_union(&self) -> &[char] {
        self.char_set_union.as_ref()
    }

    /// Calculates the entropy in bits of the passwords generated by this specification.
    pub fn entropy(&self) -> f64 {
        // number of possible passwords = N^L
        //   N: number of characters to sample from
        //   L: length of password
        // entropy in bits = log_2(N^L)
        //   = L * log_2(N)

        let n = self.char_set_union.len() as f64;
        let l = self.length.get() as f64;
        l * n.log2()
    }
}

/// An iterator which generates new passwords endlessly.
#[derive(Debug)]
pub struct Generator<R: RngCore + CryptoRng> {
    rng: R,
    spec: PasswordSpec,
}

impl<R: RngCore + CryptoRng> Generator<R> {
    /// Create a new generator from a password specification, using a specific CSPRNG.
    pub fn new(rng: R, spec: PasswordSpec) -> Self {
        Self { rng, spec }
    }
}

impl<R: RngCore + CryptoRng> Iterator for Generator<R> {
    type Item = String;

    fn next(&mut self) -> Option<Self::Item> {
        use rand::seq::SliceRandom;
        let password = (0..self.spec.length().get())
            .map(|_| {
                self.spec.char_set_union().choose(&mut self.rng).unwrap() // can't panic, because PasswordSpec::char_set_union() is non-empty
            })
            .collect();
        Some(password)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "vector of character sets must not be empty")]
    fn password_spec_no_char_sets() {
        PasswordSpec::new(1.try_into().unwrap(), vec![]);
    }

    #[test]
    #[should_panic(expected = "character sets must not be empty")]
    fn password_spec_empty_char_sets() {
        PasswordSpec::new(1.try_into().unwrap(), vec![CharSet::new()]);
    }
}
